{"meta":{"title":"繁书","subtitle":"记录技术与生活的笔记本","description":null,"author":"捻捻转儿","url":"https://mrpeak.github.io"},"pages":[{"title":"resume","date":"2016-06-13T06:09:52.000Z","updated":"2016-06-13T06:15:32.000Z","comments":true,"path":"/resume.html","permalink":"https://mrpeak.github.io//resume.html","excerpt":"","text":"高峰的简历（求职意向：前端开发） Getting Started 一位擅长前端的Web开发者，现就职于 Alibaba ICBU，负责阿里巴巴国际站&amp;多语言15个国家站首页、全站PC端搜索List、多语言前台页面（除独立Detail页）、卖家反作弊后台、搜索SEO优化、Mobile版搜索List的开发跟维护工作 Introduce 姓名 ： 高峰 昵称 ： 捻捻转儿 性别 ： 男 家乡 ： 天津市 现居 ： 杭州市 学历 ： 本科（电子科技大学 UESTC） 政治面貌 ： 丑陋 婚姻情况 ： 非单身未婚 个人网站 ： http://www.gyroer.com 在线简历 ： http://resume.gyroer.com Gmail ： gfeng.peak@gmail.com Github ： https://github.com/MrPeak WeChat ： 569052161 Tags 高效／Mac党／运动／创新／自大／爱玩儿／兴趣驱动／厌恶稳定／自我批判／大明山车神 Features 技能 ## JavaScript ➜ Client JS : [########################################] 80% ➜ Server JS : [####################################] 72% ➜ JS Library : [#########################################] 82% ➜ JS Framework: [###################################] 70% ➜ NoSQL: : [#########################] 50% ## Java &amp;&amp; PHP &amp;&amp; Python ➜ Java SE : [####################] 40% ➜ PHP : [#########################] 50% ➜ Python : [#####################] 42% ## Markup language ➜ HTML/XML : [#######################################] 78% ➜ CSS/CSS3 : [##################################] 68% 惯性 每天阅读微信订阅、知乎专栏、微博分享每周阅读订阅的邮件周刊（国内外业界Weekly）技术保鲜，保持学习跟实践“必先利其器” 信奉者，不对开发工具妥协注释洁癖，相信“再牛逼的代码没有注释也是一坨屎” Plan Features 出色的业务协调能力优秀的时间管理能力开源社区的贡献能力信仰年轻 Change Log 0.9.6 - 2014.07 来到现在的城市杭州，就职阿里巴巴（滨江总部）ICBU至今 0.9.5 - 2014.06 毕业季，离开成都这个最喜欢无之一的城市 0.9.4 — 2013.04 Mile Stone 实习面试通过，进入 Baidu LBS事业部，开发一系列导航、地图的内部工具，后加入产品研发团队，参与百度地图Web端开发 0.9.3 — 2012.12 学院搬校区，加入Syslab实验室，接手学校和校外商家的外包项目 0.9.2 — 2012.04 加入星辰工作室，参与电子科技大学官方BBS清水河畔的开发维护工作 0.9.1 — 2011.10 组建 微电子与固体电子学院 网络技术小组，开发学院门户网站 0.9.0 — 2010.09 入学坐落于 天府之国成都 的电子科技大学（985，211），主修电子科学与技术专业 . . . . . . 0.8.1 — 2008.xx 使用 Dreamweaver 学习网页开发 0.8.0 — 2007.09 入学天津市第一中学 . . . . . . 0.1.0 — 1991.5.22 天津妇产科医院降生一名奇婴 Download Download pdf"},{"title":"关于我","date":"2016-06-13T09:35:08.000Z","updated":"2016-06-13T09:35:08.000Z","comments":true,"path":"about/index.html","permalink":"https://mrpeak.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2016-06-13T09:35:18.000Z","updated":"2016-06-13T09:35:18.000Z","comments":false,"path":"tags/index.html","permalink":"https://mrpeak.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Sass代码的SassDoc注释","slug":"sass-annotation","date":"2016-01-28T14:07:25.000Z","updated":"2016-06-13T09:22:17.000Z","comments":true,"path":"2016/01/28/sass-annotation/","link":"","permalink":"https://mrpeak.github.io/2016/01/28/sass-annotation/","excerpt":"这篇文章中我们详细说明下开发Sass代码时, 可以书写的注释有哪些类型 通过SassDoc, 开发者可以像书写JSDoc一样编写Sass的注释代码, 然后通过命令快速生成API文档","text":"这篇文章中我们详细说明下开发Sass代码时, 可以书写的注释有哪些类型 通过SassDoc, 开发者可以像书写JSDoc一样编写Sass的注释代码, 然后通过命令快速生成API文档 SassDoc使用详情, 猛戳SassDoc传送门 原生的注释类型多行注释Example: 123456789/* This is a variantof a multi-linecomment. */.selector &#123; color: #fff; font-size: 16px; text-align: right;&#125; 注意：多行注释在编译后会被直接输出到CSS代码中 单行注释Example 1:1234567// Styles for a selector..selector &#123; color: #fff; font-size: 16px; text-align: right;&#125; Example 2:123.example-rule &#123; float: left; // Styles for LTR direction property.&#125; 注意：单行注释在编译环节将被过滤，不会输出到CSS代码中 SassDoc的注释SassDoc规范的注释代码不希望被输出到CSS代码中，因此选择了升级版 的单行注释作为注释界定符 Example: 123456/// Here is the description/// On several lines if you will/// @author Author's name/// @access private/// @alias other-item 注意：3个斜杠追加一个空格 /// 作为一行注释的起始 SassDoc的文件级别注释Example: 123456789101112131415161718/////// 这是一个文件级别的全局注释/// 该文件内的所有Item都将被应用该注释的描述/// @group API/// @author gaofeng.gf/////// 该Item从文件级注释继承了/// `@group API` 与 `@author gaofeng.gf` 两个注释项@function dummy-function() &#123; // ...&#125;/// 该Item覆写了 `@author` 这个从全局继承的注释项/// @author zhouyuan.yz@mixin dummy-mixin &#123; // ...&#125; 注意：4个斜杠追加一个空格 //// 作为文件级注释的『起始』与『结束』 数据类型 SassScript 支持7大数据类型 numbers (如 1.2, 13, 10px) strings (如 “foo”, ‘bar’, baz) colors (如 blue, #04a3f9, rgba(255, 0, 0, 0.5)) booleans (如 true, false) nulls (如 null) lists (以逗号或空格分隔，如 1.5em 1em 0 2em, Helvetica, Arial, sans-serif) maps (如 (key1: value1, key2: value2)) 在注释数据类型中分别对应： Number String Color Bool Null List Map 注释项 注释声明 描述 别称 默认值 使用范围 补充说明 @access 定义功能块的访问类型 - public functions, mixins, placeholders, variables 为private类型时，sassdoc将在生成文档时忽略此功能块 @alias 描述该功能块是否是其他功能块的别称 - - functions, mixins, placeholders, variables - @author 功能块开发者 - - functions, mixins, placeholders, variables - @content 对@content指令的用法进行描述 - - mixins - @deprecated 标识该功能模块已废弃 - - functions, mixins, placeholders, variables 可在描述项后面追加描述信息 @example 功能块使用示例 - - functions, mixins, placeholders, variables 1. 示例内容需要缩进; 2.@example（空格）后可追加需要高亮的语法，支持 css, scss, markup, javascript 四种语法 最佳实践 @group 该功能块所属的分组 - undefined functions, mixins, placeholders, variables 分组定义了功能块在文档中的展示方式 @ignore 声明该行注释将不会被生成文档条目 - - functions, mixins, placeholders, variables - @link 链接 @source - functions, mixins, placeholders, variables 超链接（空格）后可追加链接标题 @name 自定义功能块在文档中的显示名 - item.context.name functions, mixins, placeholders, variables - @output 对@mixin指令输出的内容进行描述 @outputs - mixins - @parameter 对功能块的功能参数进行描述 @arg, @argument, @param - functions, mixins 1. 默认值可选 2.参数描述可选 3.如有多类型用竖线符号分隔 最佳实践 @property 记录映射maps类型变量的属性，使用’.’进行嵌套属性访问 @prop - variables 同@parameter @require 对该功能块依赖其他功能块进行描述 @requires - functions, mixins, placeholders, variables - @return 对函数的返回结果进行描述 @returns - functions 如有多类型用竖线符号分隔 @see 记录了与该功能块关联的功能块 - - functions, mixins, placeholders, variables - @since 记录该功能块开始实现的版本号 - - functions, mixins, placeholders, variables 版本号（空格）后可追加版本描述 @throw 记录一个被功能块 @error 指令抛出的错误信息 @throws, @exception - functions, mixins, placeholders - @todo 记录关于功能块的待做任务 - - functions, mixins, placeholders, variables - @type 描述变量的类型 - - variables 如有多类型用竖线符号分隔 最佳实践 Variable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@charset \"UTF-8\";/////// 我是该文件的全局注释，对文件内的所有功能块均生效////// @group Variable/// @author jack.ma/////// 通用错误信息/// @type String$error-massege: \"编译错误，请检查代码！\";/// 通用步长/// @type Number$step-number: 4;/// 是否是开发版本/// @type Bool$is-dev: true;/// 通用占位变量/// @type Null$placeholder: null;/// 通用背景色/// @type Color$background-color: rgba(1, 2, 3, 0.6);/// 媒体查询断点映射 - List类型/// @type List$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618) );/// 媒体查询断点映射 - Map类型/// @type Map/// @property &#123;String&#125; breakpoint-map.small - 小屏幕断点/// @property &#123;String&#125; breakpoint-map.medium - 中等屏幕断点/// @property &#123;String&#125; breakpoint-map.large [1200px] - 大屏幕断点$breakpoint-map: ( small: 767px, medium: 992px, large: 1200px); Function12345678910111213141516171819202122232425262728293031@charset \"UTF-8\";/////// 我是该文件的全局注释，对文件内的所有功能块均生效////// @group Function/// @author jack.ma/////// 检查一个值是否为合法的CSS长度////// @since 1.0.1/// @access public/// @param &#123;String&#125; $value - 长度/// @throw 当值为`1`时抛出错误/// @return &#123;Bool&#125; 是否是长度/// @todo 检查 CSS Next 中的长度/// @link http://gitlab.alibaba-inc.com@function is-length($value) &#123; @warn \"我是警告信息！不会导致编译失败\"; @debug \"我是调试信息！不会导致编译失败\"; @if $value == 1 &#123; @error \"我是错误信息：数字1肯定不是参数，编译失败！\"; &#125; @return type-of($value) != \"null\" and (str-slice($value + \"\", 1, 4) == \"calc\" /// 是calc函数来计算的长度 or (type-of(index(auto inherit initial 0, $value)) == \"number\") or (type-of($value) == \"number\" and not(unitless($value))));&#125; Mixin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@charset \"UTF-8\";/////// 我是该文件的全局注释，对文件内的所有功能块均生效////// @group Mixin/// @author jack.ma/////// 提供了快捷设置元素postion的方法，传入null参数可略过一个方位///////// @since 0.1.9/// @group Mixin////// @param &#123;String&#125; $position [relative] - CSS position属性值/// @param &#123;List&#125; $coordinates [null null null null] - 上、右、下、左 四个边值，可以传入1 ~ 4个值////// @output 输出定位属性值以及四个方位的距离////// @example scss - 使用/// .element &#123;/// @include position(absolute, 0 null null 10px);/// &#125;////// @example css - 输出/// .element &#123;/// position: absolute;/// left: 10px;/// top: 0;/// &#125;/// @see &#123;mixin&#125; box/// @require &#123;function&#125; is-length/// @require &#123;function&#125; unpack////// @ignore 我是将要被忽略的注释行信息@mixin position($position: relative, $coordinates: null null null null) &#123; /// 如果参数是数组 @if type-of($position) == list &#123; $coordinates: $position; $position: relative; &#125; $coordinates: unpack($coordinates); $offsets: ( top: nth($coordinates, 1), right: nth($coordinates, 2), bottom: nth($coordinates, 3), left: nth($coordinates, 4) ); position: $position; @each $offset, $value in $offsets &#123; /// 如果是合法长度 @if is-length($value) &#123; #&#123;$offset&#125;: $value; &#125; &#125;&#125;/// 媒体查询混入////// @since 0.1.9/// @group Mixin/// @content 任意CSS样式/// @access public////// @param &#123;String&#125; $width - CSS宽度值////// @example scss - 使用/// .element &#123;/// color: #333; /// /// @include media(320px) &#123;/// background: red;/// &#125;/// &#125;////// @example css - 输出/// .element &#123;/// color: #333;/// &#125;/// /// @media only screen and (max-width: 320px) &#123;/// .element &#123;/// background: red;/// &#125;/// &#125;@mixin media($width) &#123; @media only screen and (max-width: $width) &#123; @content; &#125;&#125;.element &#123; color: #333; @include media(320px) &#123; background: red; &#125;&#125; Placeholder1234567891011121314151617181920212223242526272829303132333435363738394041@charset \"UTF-8\";/////// 我是该文件的全局注释，对文件内的所有功能块均生效////// @group Placeholder/// @author jack.ma/////// 图标通用代码////// @deprecated/// @name common-icon/// @example scss - 使用/// .error-icon &#123;/// @extend %icon;/// /* error specific styles... *//// &#125;/// .info-icon &#123;/// @extend %icon;/// /* info specific styles... *//// &#125;////// @example css - 输出/// .error-icon, .info-icon &#123;/// transition: background-color ease .2s;/// margin: 0 .5em;/// &#125;////// .error-icon &#123;/// /* error specific styles... *//// &#125;////// .info-icon &#123;/// /* info specific styles... *//// &#125;/// @todo 大版本迭代时去除%icon &#123; transition: background-color ease .2s; margin: 0 .5em;&#125; 详情查看 http://sassdoc.com/annotations/","categories":[],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://mrpeak.github.io/tags/Sass/"}]},{"title":"Ruby Sass 与 Lib Sass","slug":"sass-type","date":"2015-12-01T09:00:08.000Z","updated":"2016-06-13T09:06:35.000Z","comments":true,"path":"2015/12/01/sass-type/","link":"","permalink":"https://mrpeak.github.io/2015/12/01/sass-type/","excerpt":"当你用 Sass 用得飞起时，如果突然听说一种叫 LibSass的sass语言已经火起来了，可能你会跳起来说：『LibSass 到底是个什么鬼！我是不是应该舍弃 Ruby Sass 然后投奔 LibSass , 我难道落伍了 ???』 稍安勿躁，你并没有落伍，读到后面你将了解到 Ruby Sass 跟 LibSass 是相似的产物，而它俩的主要区别体现在接口调用、编译速度、功能支持这三点上","text":"当你用 Sass 用得飞起时，如果突然听说一种叫 LibSass的sass语言已经火起来了，可能你会跳起来说：『LibSass 到底是个什么鬼！我是不是应该舍弃 Ruby Sass 然后投奔 LibSass , 我难道落伍了 ???』 稍安勿躁，你并没有落伍，读到后面你将了解到 Ruby Sass 跟 LibSass 是相似的产物，而它俩的主要区别体现在接口调用、编译速度、功能支持这三点上 在这片文章里，连同 Ruby Sass 与 LibSass 的优缺点，我会全面地解释两者的区别 Ruby Sass最开始，Sass 是由 Ruby 编写的，如果你刚使用 Sass 不久，你很有可能在使用的是这种 Sass。只要你本地运行了 Ruby，安装了 Sass，运行了编译器，你就可以使用 Sass 所有屌屌的功能跟特性了。 但是！只要脱离了 Ruby 环境，你的 Ruby Sass 就无法运行了。取决于你的项目文件的大小，Ruby Sass 引擎可能会花很长时间来编译，你的工程越庞大，那编译花费的时间就会越久，在开发大工程时需要尤其注意这点。 如果你的机器没有运行 Ruby，或者在大工程中需要花费很久来把 sass 编译成 css，你会怎么做？ 走近 LibSassLibSass 是 Sass引擎的一套 C/C++ 接口实现，它不依赖 Ruby 环境就可以把sass 编译成 css，因此它能够被集成到其他语言中去。 LibSass自己本身不做任何事，它只是一个库，为了能让它工作，你需要一个包装器（或者是接口实现）来运行这个库，同时来编译你的样式表。这其中最常用的 LibSass 几个包装器分别是 SassC（第一个被开发）；node-sass, grunt-sass – 甚至有一个Ruby实现的包装器 举例来说，如果项目中运行了 node-sass, 那么 LibSass 就在 node-sass 包装器在 Node.js 里执行编译时作为核心库存在 为什么选择 LibSass?使用 LibSass, 你不再需要将开发跟 Ruby 环境依赖捆在一起。使用繁多的包装器，你可以轻而易举地将 Sass 编译集成在几乎所有语言。 使用 LibSass 最棒的一点体现在编译速度上，跟 Ruby Sass 相比，LibSass 非常显著的快了4000%倍。看一看 Ruby Sass, LibSass 以及其它 CSS 预处理器的编译时间对比吧！ 兼容 Ruby Sass ？LibSass 并不完美，很多开发者还在犹豫是否要将代码迁移到 LibSass ，因为涉及到某些功能特性时，它仍然落后于 Ruby Sass。（译者注：目前LibSass 3.3已经完全实现了新旧Ruby Sass的所有功能特性！） 例如，@at-root, @error，以及很多3.4版本 Sass 的新特性在 LibSass 中都不支持。想全面了解 Sass, LibSass, 以及老Sass引擎的功能支持差异，看一看这个网站吧 LibSass 的前途一片光明! 好消息是 LibSass 很快将追上 Ruby Sass 的脚步，只要这一步实现了，两者之间的功能特性将会继续向前发展。很快我们就能兼顾 LibSass飞快的编译速度 与 Ruby Sass丰富的功能 了。 去 SassMeister 就能快速测试 Ruby Sass 与 LibSass 之间的差异！ 最后的感想只要你投入 LibSass 的怀抱, 你就会发现跟使用 Ruby Sass 一样的简单，编译速度却快得多！并且如果你仅仅使用了 Sass 的核心功能，将代码迁移到 LibSass 似乎是没什么风险的。 如果你、你的团队以及你的项目偏向使用 Ruby Sass，那么就坚持使用它！取决于项目大小，LibSass的速度优势带来的价值可能会大于暂时缺失一小部分Sass功能这一劣势损失的价值。 原文链接：http://sassbreak.com/ruby-sass-libsass-differences/","categories":[],"tags":[{"name":"Sass","slug":"Sass","permalink":"https://mrpeak.github.io/tags/Sass/"}]},{"title":"Visual Studio Code 不完全使用指南","slug":"vscode-guide","date":"2015-07-02T08:52:56.000Z","updated":"2016-06-13T09:01:02.000Z","comments":true,"path":"2015/07/02/vscode-guide/","link":"","permalink":"https://mrpeak.github.io/2015/07/02/vscode-guide/","excerpt":"Visual Studio Code 是“巨硬”基于 Electron 开发的一款轻量级编辑器，主打 web 开发，支持的语言包括： JavaScript C# JSON HTML Markdown TypeScript CSS, Sass, Less DockerFile Swift Groovy 不断增加中…","text":"Visual Studio Code 是“巨硬”基于 Electron 开发的一款轻量级编辑器，主打 web 开发，支持的语言包括： JavaScript C# JSON HTML Markdown TypeScript CSS, Sass, Less DockerFile Swift Groovy 不断增加中… 快速导航VS Code 提供了类似于 Sublime 的多功能输入框，Command + P 即可调用出 不使用前缀字符，可以进行工程内的文件搜索；输入前缀字符 ? 可以查看所有命令列表（全局命令 + 编辑器命令），其中 &gt; 前缀的使用最为频繁，通过它我们可以找到所有的命令，excited! 编辑功能 多光标选取 Alt + 鼠标单击 逐步选中其它相同的symbol Command + D， 全选相同symbol Command + F12 代码格式化 Shift + Alt + F 重构（重命名）Symbol F2 查找所有引用了选中symbol的代码 Shift + F12 跳转到symbol的定义处 F12 瞥见下symbol的定义出（在该symbol下方展开面板，显示定义处代码，非常有用）Alt + F12 跳转到光标上一次(下一次)位置（误操作的回退方案，非常有用） Command + Left / Command + Right 语法提示VS Code 的语法提示之强大令人发指，对于支持的语言有着很好的支持，同时对于函数方法也有参数的提示 对于业界知名框架与库，也可以通过强大的 *.d.ts 文件来支持语法提示、参数提示，如我在项目中使用了 angular，键入 angular 命名空间，1s后出现小灯泡，然后点击它，选中”download…”后编辑器就开始后台下载了，成功后会有提示 jQuery, Backbone, Underscore, Lodash, Node.js, Express, Restify, Async 等等知名开源框架跟库的提示都可以直接通过 tsd 来管理，非常方便 无论通过小灯泡点击安装的还是通过tsd安装的ts文件，都会被放置在工程的根路径下的typings文件夹中，方便查看已有的提示插件 开启ES6语法支持VS Code 默认支持 ES5 的语法，你的代码如果过用到了ES6的特性，又不想被内建的lint工具提示语法错误的话，你需要手动开启。在项目Proj根目录下新建jsoconfig.js文件，添加如下代码： 12345&#123; \"compilerOptions\": &#123; \"target\": \"ES6\" &#125;&#125; 保存该文件 –&gt; 重启编辑器，ES6 语法在该项目就已支持，内建lint工具也不会再提示错误了 调试Node.js在本地安装 Mono 并将其加入环境变量中后，可以调试 Node.js 程序，调试操作类似于 WebStorm，先要进行debug的配置工作，通过切换到 Debug 面板，点击绿色启动按钮，这时编辑器会在工程根文件夹下新加 .setting 文件夹，Node.js的启动/调试配置文件、Task的配置文件都会放置在此。 这里Node.js配置的文件名为 launch.json： 12345678910111213141516171819202122232425262728293031323334353637383940&#123; \"version\": \"0.1.0\", // List of configurations. Add new configurations or edit existing ones. // ONLY \"node\" and \"mono\" are supported, change \"type\" to switch. \"configurations\": [ &#123; // Name of configuration; appears in the launch configuration drop down menu. \"name\": \"Launch env\", // Type of configuration. Possible values: \"node\", \"mono\". \"type\": \"node\", // Workspace relative or absolute path to the program. \"program\": \"env\", // Automatically stop program after launch. \"stopOnEntry\": false, // Command line arguments passed to the program. \"args\": [], // Workspace relative or absolute path to the working directory of the program being debugged. Default is the current workspace. \"cwd\": \".\", // Workspace relative or absolute path to the runtime executable to be used. Default is the runtime executable on the PATH. \"runtimeExecutable\": null, // Optional arguments passed to the runtime executable. \"runtimeArgs\": [\"--nolazy\", \"--harmony\"], // Environment variables passed to the program. \"env\": &#123; &#125;, // Use JavaScript source maps (if they exist). \"sourceMaps\": false, // If JavaScript source maps are enabled, the generated code is expected in this directory. \"outDir\": null &#125;, &#123; \"name\": \"Attach\", \"type\": \"node\", // TCP/IP address. Default is \"localhost\". \"address\": \"localhost\", // Port to attach to. \"port\": 5858, \"sourceMaps\": false &#125; ]&#125; 注：Node.js代码中含有ES6特性的代码，需要开启”–harmony”，因此 runtimeArgs 需要添加一项 “–harmony” 常用的添加环境变量，添加应用参数，node的执行参数等操作都能在这里进行修改，配置完成后再次点击绿色的启动按钮，VSCode就可以开始启动服务了，同时监听了5858端口进行调试操作 VSCode Debug 操作与浏览器开发者工具、Webstorm调试工具累似，但是自身没有提供命令行终端的信息显示，因此在调试时会打开系统的默认shell进行程序运行的信息显示 支持Markdown强大的 Sublime Text 2/3 同样支持Markdown语法高亮，但是预览功能却需要插件来实现，可以一键在浏览器中预览。而 VS Code 自带预览功能，Command + Shift + v 可以进行原生地预览，通过开启两栏编辑器可以实现实时预览 同其他独立 Markdown Editor （Mou、MacDown、马克飞🐘等等）一样，VS Code同样可以设置 .md 文件的预览样式，通过快捷键组 Command + , 可以快速打开 User Settings 文件，添加如下字段 123\"markdown.styles\": [ \"https://jasonm23.github.io/markdown-css-themes/screen.css\"] markdown.styles 字段值是一个样式URL的数组，通过指定，我们的预览便在外部样式表(.css文件)的作用下改变了样式，对于颜控党来说美腻的皮肤总是能为书写（开发）带来额外的动力 缤彩主题请戳我 配置任务VS Code 提供了配置 task.json 文件来快捷键运行 Task 的功能，如 Markdown -&gt; HTML: 123456&#123; \"version\": \"0.1.0\", \"command\": \"marked\", \"isShellCommand\": true, \"args\": [\"sample.md\", \"-o\", \"sample.html\"]&#125; 配置好后在markdown文件焦点处按下快捷键 “Command + Shift + B”即可编译转换，类似也可以运行其他可以通过命令号工具调用的工具，如lessc、gulp、grunt等等 个人觉得目前Task功能很鸡肋，连基本的 watcher 功能都要依赖 Gulp 来实现，而大多数任务通过简单的命令行调用即可，书写配置文件有时候反而把简单的事搞复杂了，况且 package.json 的 scripts 字段已经赋予了项目通过配置来运行任务的功能了 1234567891011\"scripts\": &#123; \"start\": \"NODE_ENV=production node --harmony server-side/server.js\", \"dev\": \"NODE_ENV=development node --debug --harmony server-side/server.js\", \"pm2\": \"NODE_ENV=production pm2 start server-side/server.js --node-args=\\\"--harmony\\\"\", \"pm2-dev\": \"NODE_ENV=development pm2 start server-side/server.js --node-args=\\\"--harmony\\\"\", \"local\": \"NODE_ENV=local nodemon --debug --harmony server-side/server.js\", \"test\": \"npm run test-jshint &amp;&amp; npm run test-mocha\", \"test-mocha\": \"NODE_ENV=test mocha --harmony ./server-side/**/*.spec.js\", \"test-jshint\": \"jshint -c .jshintrc server-cd side/**/*.js --exclude server-side/**/*.spec.js --reporter node_modules/jshint-stylish/stylish.js\", \"test-mocha-watch\": \"NODE_ENV=test mocha --watch --harmony ./server-side/**/*.spec.js\"&#125;, 版本控制VS Code 支持Git版本控制，提供了基本的stage、commit、fetch、pull、push等Git常用功能，设置项默认开启了后台的 auto git fetch，右侧面板的第三个便是Git管理工具的UI了，点开后当前工程文件的 status 一目了然，通过点击加号就可以把变更的文件 stage 。编辑器提供的Commit Message输入框还可以让开发者填写多行提交信息（命令行工具不支持） 它提供了建议的Color Diff工具，清晰地让开发者看到文件变更的差异，提高了diff的效率 编辑器底部工具栏左下角清晰地显示了当前开发所处的分支 点击当前分支，编辑器会弹出所有（远程、本地）分支以供切换，人性化十足 仍有不足 插件系统的缺乏 编辑器配色缺乏 仍需要更多语言的支持 本地文件历史快照缺乏 光标位置历史的前进、后退 ^_^ 欢迎补充","categories":[],"tags":[{"name":"IDE","slug":"IDE","permalink":"https://mrpeak.github.io/tags/IDE/"}]},{"title":"Mongoose 的 Promise 化","slug":"mongoose-promise","date":"2015-03-20T13:05:39.000Z","updated":"2016-06-13T08:50:12.000Z","comments":true,"path":"2015/03/20/mongoose-promise/","link":"","permalink":"https://mrpeak.github.io/2015/03/20/mongoose-promise/","excerpt":"在NodeJS环境下使用MongoDB时，作为数据库管理工具的Mongoose已经成为项目开发的标配，它丰富了Mongo的原生API，为开发者提供了扩展接口，同时以 schema-based 的方式，来操作Mongo 在开发Node时读写数据库难免要进行频繁且深层次的回调操作好在Mongoose的读写操作都有方法以 promise 对象返回，基于这点，结合其它三方Promise类库，可以避免多重嵌套的发生。（ES6 Generator 能更好的控制异步流程，结合Promise可以更好的解决 Callback Hell）","text":"在NodeJS环境下使用MongoDB时，作为数据库管理工具的Mongoose已经成为项目开发的标配，它丰富了Mongo的原生API，为开发者提供了扩展接口，同时以 schema-based 的方式，来操作Mongo 在开发Node时读写数据库难免要进行频繁且深层次的回调操作好在Mongoose的读写操作都有方法以 promise 对象返回，基于这点，结合其它三方Promise类库，可以避免多重嵌套的发生。（ES6 Generator 能更好的控制异步流程，结合Promise可以更好的解决 Callback Hell） Talk is cheap. Show me the code 先建立我们的数据模型 —— Family 12345678910111213141516171819var mongoose = require('mongoose');var Schema = mongoose.Schema; var FamilySchema = new mongoose.Schema(&#123; generation: &#123; type: Number, default: 1 &#125;, sex: &#123; type: String, default: 'male' &#125;, name: &#123; type: String, default: '' &#125;&#125;); var Family = mongoose.model('Family', FamilySchema); Mongsoose 的Model层API 大致分为：创建（Create）、更新（Update）、读取（Find）和删除（Remove）四类，create 和 remove 操作返回 promise 对象，update 和 find 操作返回 query 对象，需要注意的是，使用 find前缀 方法（如：Model.findOneAndRemove、Model.findByIdAndRemove、Model.findByIdAndUpdate）时返回对象均为 query 对于 query 对象，只需要对其调用 exec 方法，就可以返回 promise 对象了 123456789101112131415161718192021222324252627282930313233/** * Query */Family.findOne(&#123;name: '转二'&#125;).exec(); // Return promise/** * Update */Family.findByIdAndUpdate(id, &#123;$set: &#123; name: '转二', generation: 3&#125;&#125;).exec(); // Return promise/** * Create */var array = [&#123; generation: 4, sex: female, name: '虫虫'&#125;, &#123; generation: 3, sex: female, name: '芮芮'&#125;];Family.create(array); // Return promise/** * Delete */Family.remove(&#123; name: '转二' &#125;); // Return promise 有了 promise 返回，异步梦魇已经解决一半了 在 promise 类库中我比较喜欢Q，相比于其他同类工具，Q比较简单，而且和 Angular 的 $q 和 jQuery 的 Deferred 语法相似。不过还是推荐使用 es6-promise，作为 polyfill 可以让代码在未来无缝衔接 es6 为了举例子，现在创建第二个数据模型 —— Company 12345678910var mongoose = require('mongoose');var Schema = mongoose.Schema;var CompanyMemberSchema = new mongoose.Schema(&#123; empName: String, empId: String, sex: String&#125;); var CompanyMember = mongoose.model('CompanyMember', CompanyMemberSchema); 我们想要从一个 Family 中通过 _id 找到一个家庭成员，通过这个成员的名字，在某个确定的公司里查找此人，然后把此人从公司名单中移除 Without promise1234567891011121314151617var id = \"1237213921936129\";Family.find(&#123;_id: id&#125;, function(err, persons) &#123; CompanyMember.findOne(&#123; 'empName': persons[0]['name'] &#125;, function(err, person) &#123; CompanyMember.remove(&#123; 'empId': person.empId &#125;, function(err, person) &#123; if(err) &#123; return console.error(err); &#125; console.log('Remove' + person + 'successfully!'); &#125;) &#125;)&#125;); With promise (Q)12345678910111213141516171819202122232425262728var id = \"1237213921936129\"; Q.fcall(function() &#123; return Family.findOne(&#123; _id: id &#125;).exec(); // 返回 promise&#125;).then(function(person) &#123; return CompanyMember.findOne(&#123; empName: person['name'] &#125;).exec(); // 返回 promise&#125;).then(function(person) &#123; return Company.remove(&#123;empId: person['empId']&#125;); // 返回 promise&#125;).then(function(person) &#123; console.log('Remove' + person + 'successfully!');&#125;).catch(function (err) &#123; // 捕捉错误 return console.error(err);&#125;).done(); // 结束链式调用 至于并发控制，Q 也有解决方案： 123456Q.spread([promiseA, promiseB], function(A_value, B_value) &#123; console.log('A_value': A_value); console.log('B_value': B_value);&#125;, funcion(err) &#123; return console.error(err); &#125;); Q的使用查阅 http://documentup.com/kriskowal/q/Mongoose的使用查阅 http://mongoosejs.com/docs/guide.html 下一篇会聊一聊 Generator + Promise 组合来解决 Mongoose 的异步回调问题","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://mrpeak.github.io/tags/MongoDB/"}]},{"title":"不为人知的前端冷知识","slug":"cool-fe","date":"2015-02-23T08:06:44.000Z","updated":"2016-06-13T08:11:17.000Z","comments":true,"path":"2015/02/23/cool-fe/","link":"","permalink":"https://mrpeak.github.io/2015/02/23/cool-fe/","excerpt":"前端已经被玩儿坏了！像console.log()可以向控制台输出图片等炫酷的玩意已经不是什么新闻了，像用||操作符给变量赋默认值也是人尽皆知的旧闻了，今天看到Quora上一个帖子，瞬间又GET了好多前端技能，一些属于技巧，一些则是闻所未闻的冷知识，一时间还消化不过来。现分类整理出来分享给大家，也补充了一些平时的积累和扩展了一些内容。","text":"前端已经被玩儿坏了！像console.log()可以向控制台输出图片等炫酷的玩意已经不是什么新闻了，像用||操作符给变量赋默认值也是人尽皆知的旧闻了，今天看到Quora上一个帖子，瞬间又GET了好多前端技能，一些属于技巧，一些则是闻所未闻的冷知识，一时间还消化不过来。现分类整理出来分享给大家，也补充了一些平时的积累和扩展了一些内容。 HTML篇浏览器地址栏运行JavaScript代码这个很多人应该还是知道的，在浏览器地址栏可以直接运行JavaScript代码，做法是以javascript:开头后跟要执行的语句。比如： javascript:alert('hello from address bar :)'); 将以上代码贴到浏览器地址栏回车后alert正常执行，一个弹窗神现。 需要注意的是如果是通过copy paste代码到浏览器地址栏的话，IE及Chrome会自动去掉代码开头的javascript:，所以需要手动添加起来才能正确执行，而Firefox中虽然不会自动去掉，但它根本就不支持在地址栏运行JS代码，sigh~ 这一技术在我的另一篇博文《让Chrome 接管邮件连接，收发邮件更方便了》中有使用到，利用在浏览器地址栏中执行JavaScript代码将Gmail设置为系统的邮件接管程序。 浏览器地址栏运行HTML代码如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非IE内核的浏览器地址栏可以直接运行HTML代码！ 比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。 data:text/html,Hello, world!h1> 你造么，可以把浏览器当编辑器还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与Windows自带的notepad一样，吼吼。 data:text/html, 归根结底多亏了HTML5中新加的contenteditable属性，当元素指定了该属性后，元素的内容成为可编辑状态。 推而广之，将以下代码放到console执行后，整个页面将变得可编辑，随意践踏吧~ document.body.contentEditable='true'; 利用a标签自动解析URL很多时候我们有从一个URL中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在JS代码里先创建一个a标签然后将需要解析的URL赋值给a的href属性，然后就得到了一切我们想要的了。 var a = document.createElement('a'); a.href = 'http://www.cnblogs.com/wayou/p/'; console.log(a.host); 利用这一原理，稍微扩展一下，就得到了一个更加健壮的解析URL各部分的通用方法了。下面代码来自James的博客。 function parseURL(url) { var a = document.createElement('a'); a.href = url; return { source: url, protocol: a.protocol.replace(':',''), host: a.hostname, port: a.port, query: a.search, params: (function(){ var ret = {}, seg = a.search.replace(/^\\?/,'').split('&'), len = seg.length, i = 0, s; for (;i console.log(sample); script> 加载CDN文件时，可以省掉HTTP标识现在很流行的CDN即从专门的服务器加载一些通用的JS和CSS文件，出于安全考虑有的CDN服务器使用HTTPS方式连接，而有的是传统的HTTP，其实我们在使用时可以忽略掉这个，将它从URL中省去。 script> 这一点在之前一篇译文博客《jQuery编程最佳实践》中也有提到。 利用script标签保存任意信息将script标签设置为type=’text’然后可以在里面保存任意信息，之后可以在JavaScript代码中很方便地获取。 This won't display script> var text = document.getElementById('template').innerHTML CSS篇关于CSS的恶作剧相信你看完以下代码后能够预料到会出现什么效果。 *{ cursor: none!important; } 简单的文字模糊效果以下两行简单的CSS3代码可达到将文字模糊化处理的目的，出来的效果有点像使用PS的滤镜，socool! p { color: transparent; text-shadow: #111 0 0 5px; } 垂直居中有好多次博主都有这样的需求，垂直居中显示某个DIV，我们知道CSS中天然有水平居中的样式text-align:center。唯独这个垂直居中无解。 当然你可以将容器设置为display:table，然后将子元素也就是要垂直居中显示的元素设置为display:table-cell，然后加上vertical-align:middle来实现，但此种实现往往会因为display：table而破坏整体布局，那还不如直接用table标签了呢。 下面这个样式利用了translate来巧妙实现了垂直居中样式，需IE9+。 .center-vertical { position: relative; top: 50%; transform: translateY(-50%); } 相比而言，水平居中要简单得多，像上面提到的text-align:center，经常用到的技巧还有margin:0 auto。但对于margin大法也只在子元素宽度小于容器宽度时管用，当子元素宽度大于容器宽度时此法失效。 如法炮制，利用left和transform同样可实现水平居中，不过意义不大，毕竟text-align和margin差不多满足需求了。 .center-horizontal { position: relative; left: 50%; transform: translateX(-50%); } 多重边框利用重复指定box-shadow来达到多个边框的效果 在线演示 /*CSS Border with Box-Shadow Example*/ div { box-shadow: 0 0 0 6px rgba(0, 0, 0, 0.2), 0 0 0 12px rgba(0, 0, 0, 0.2), 0 0 0 18px rgba(0, 0, 0, 0.2), 0 0 0 24px rgba(0, 0, 0, 0.2); height: 200px; margin: 50px auto; width: 400px } 实时编辑CSS通过设置style标签的display:block样式可以让页面的style标签显示出来，并且加上contentEditable属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在IE下无效。拥有此技能者，逆天也！ body { color: blue } style> body> html> 创建长宽比固定的元素通过设置父级窗口的padding-bottom可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。 this content will have a constant aspect ratio that varies based on the width. div> div> CSS中也可以做简单运算通过CSS中的calc方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。 .container{ background-position: calc(100% - 50px) calc(100% - 20px); } JavaScript篇生成随机字符串利用Math.random和toString生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了toString方法可以接收一个基数作为参数的原理，这个基数从2到36封顶。如果不指定，默认基数是10进制。略屌！ function generateRandomAlphaNum(len) { var rdmString = \"\"; for (; rdmString.length < len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len); } 整数的操作JavaScript中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。 |0和~~是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的parseInt,Math.round 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。 var foo = (12.4 / 4.13) | 0;//结果为3 var bar = ~~(12.4 / 4.13);//结果为3 顺便说句，!!将一个值方便快速转化为布尔值 !!window===true 。 重写原生浏览器方法以实现新功能下列代码通过重写浏览器的alert让它可以记录弹窗的次数。 (function() { var oldAlert = window.alert, count = 0; window.alert = function(a) { count++; oldAlert(a + \"\\n You've called alert \" + count + \" times now. Stop, it's evil!\"); }; })(); alert(\"Hello World\"); 关于console的恶作剧关于重写原生方法，这里有个恶作剧大家可以拿去寻开心。Chrome的console.log是支持对文字添加样式的，甚至log图片都可以。于是可以重写掉默认的log方法，把将要log的文字应用到CSS的模糊效果，这样当有人试图调用console.log()的时候，出来的是模糊不清的文字。好冷，我表示没有笑。 是从这篇G+帖子的评论里看到的。使用之后的效果是再次调用log会输出字迹模糊不清的文字。 var _log = console.log; console.log = function() { _log.call(console, '%c' + [].slice.call(arguments).join(' '), 'color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);'); }; 不声明第三个变量的值交换我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意的。 var a=1,b=2;a=[b,b=a][0]; 万物皆对象在JavaScript的世界，万物皆对象。除了null和undefined，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用toString方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以(1).toString()相当于new Number(1).toString()。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。 同时我们注意到，JavaScript中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而以，比如你看到的1可以写成1.，这也就是为什么当你试图1.toString()时会报错，所以正确的写法应该是这样：1..toString()，或者如上面所述加上括号，这里括号的作用是纠正JS解析器，不要把1后面的点当成小数点。内部实现如上面所述，是将1.用包装对象转成对象再调用方法。 If语句的变形当你需要写一个if语句的时候，不妨尝试另一种更简便的方法，用JavaScript中的逻辑操作符来代替。 var day=(new Date).getDay()===0; //传统if语句 if (day) { alert('Today is Sunday!'); }; //运用逻辑与代替if day&&alert('Today is Sunday!'); 比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的day变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的alert了，如果前面day为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了if的效果。 对于传统的if语句，如果执行体代码超过了1 条语句，则需要加花括号，而利用逗号表达式，可以执行任意条代码而不用加花括号。 if(conditoin) alert(1),alert(2),console.log(3); 上面if语句中，如果条件成立则执行三个操作，但我们不需要用花括号将这三句代码括起来。当然，这是不推荐的，这里是冷知识课堂:) 禁止别人以iframe加载你的页面下面的代码已经不言自明了，没什么好多说的。 if (window.location != window.parent.location) window.parent.location = window.location; console.tableChrome专属，IE绕道的console方法。可以将JavaScript关联数组以表格形式输出到浏览器console，效果很惊赞，界面很美观。 //采购情况 var data = [{'品名': '杜雷斯', '数量': 4}, {'品名': '冈本', '数量': 3}]; console.table(data); REFERENCE What are the most interesting HTML/JS/DOM/CSS hacks that most webdevelopers don’t knowabout? 45 Useful JavaScript Tips, Tricks and BestPractices 10 Small Things You May Not Know AboutJavascript","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://mrpeak.github.io/tags/前端/"}]},{"title":"使用 Browserify 时引入文本文件","slug":"browserify-text","date":"2015-01-05T08:33:53.000Z","updated":"2016-06-13T08:44:17.000Z","comments":true,"path":"2015/01/05/browserify-text/","link":"","permalink":"https://mrpeak.github.io/2015/01/05/browserify-text/","excerpt":"目前来讲模块化已经是Web前端开发的标配了, 主流无非是CommonJS规范和AMD规范","text":"目前来讲模块化已经是Web前端开发的标配了, 主流无非是CommonJS规范和AMD规范 RequireJS以AMD规范的翘楚 RequireJS 举例，它提供了requirejs-text插件，使得开发者可以异步地引入样式跟模板数据 12345678require([\"some/module\", \"text!some/module.html\", \"text!some/module.css\"], function(module, html, css) &#123; //the html variable will be the text //of the some/module.html file //the css variable will be the text //of the some/module.css file. &#125;); 这时候我们已经在匿名的回调函数中拿到了html和css的实参字符串，html的模板字符串可以通过innerHTML使用，但是css字符串还需要插入进style才能生效 1document.getElementsByTagName(&quot;style&quot;)[0].innerHTML = css; 这样一个模块的三个基本要素（模板、样式、脚本）就加载齐全了 SeaJSSeaJS同样使用插件实现了引入文本文件的功能 `seajs-text`实现了加载模板字符串的功能， `seajs-css`实现了加载样式表字符串的功能 `seajs-style`能够加载一个css文件，和link标签一样 Browserify如何实现 作为前端CommonJS化的宠儿，目前模块化开发的绝对主流Browserify，配合HTML5的script标签新属性async，可以无阻塞的加载模块 需要注意的是：`async`属性一旦使用，就要考虑好`browserify`打包好的那些模块是否有依赖性，如果有依赖性，建议把这些依赖的模块打包为一个模块，不然async标示过的脚本是不会等待`DomReady`之后再执行的，这样很危险 这里不会介绍Browserify的使用场景以及怎么使用，而是为了解决特定的引入文本文件的功能，这里默认大家已经知晓了它的简单使用，不明请去官网查阅 Browserify使用了transform以及配合transform的相应插件实现了引入模板、样式等等文本文件的功能 transform又是什么？ Transform source code before parsing it for require() calls with the transform function or module name tr 就是说，在解析require调用之前来转换引入的源代码，通过这一层类似于中间件的功能，使得browserify在拓展性上大有可为 注：在项目中我习惯使用CLI，用watchify配合transform插件，来实现实时转化和编译 怎么引入模板文件我使用过的三个transform插件可以实现： stringify html2js-browserify browserify-compile-templates（限定了你使用的模板引擎为Underscore Template，把单独模板放到同一html静态文件，中，通过script的ID来分别调用，灵活性欠妥，不推荐） blissify（限定了你使用的模板引擎为Biss，不推荐） stringify和html2js-browserify非常类似，使用API也类似，一起提及 项目使用中： 123npm install -S-dev browserifynpm install -S-dev watchify npm install -S-dev stringify 或者html2js-browserify 123npm install -S-dev browserifynpm install -S-dev watchify npm install -S-dev html2js-browserify 新建html文件，编写需要使用的模板（以Ejs举例） ../templates/header.html 1234567891011&lt;header&gt; &lt;nav&gt; &lt;span class=\"home\"&gt;Home&lt;/span&gt; &lt;span class=\"user\"&gt;MyZone&lt;/span&gt; &lt;% if (isAmin) &#123; %&gt; &lt;span&gt; Welcome! &lt;%= name %&gt; administer &lt;span&gt; &lt;% &#125; %&gt; &lt;/nav&gt;&lt;/header&gt; 在我们的CommonJS模块里就可以使用了 ../modules/header/header.js 12345678910var $ = require('jquery');var _ = require('underscore');var tpl = require('../../templates/header.html');var data = &#123; name: '转二'， isAdmin: true&#125;;$('.header').html(_.template(tpl)(data)); 最简单的命令行（使用wacthify附加监视功能）如下： 1browserify -t stringify header.js -o header_bundle.js 或者 1browserify -t html2js-browserify header.js -o header_bundle.js 怎么引入样式文件 无预处理器编译的 cssify browserify-css browserify-css 123npm install -S-dev browserifynpm install -S-dev watchify npm install -S-dev browserify-css app.css: 12345@import url(\"modules/foo/index.css\");@import url(\"modules/bar/index.css\");body &#123; background-color: #fff;&#125; app.js: 12var css = require('./app.css');console.log(css); 编译时如果添加参数 --autoInject=true，那么你的HTML文件的head标签将被插入style，否则需要你手动插入 1watchify -t browserify-css [ --autoInject=true ] app.js &gt; bundle.js cssify 这个插件使用的人最多，可能是因为最简单 123npm install -S-dev browserifynpm install -S-dev watchify npm install -S-dev cssify style.css: 123body &#123; background: pink;&#125; app.js: 12var styleNode = require('./style.css');console.log(styleNode); 编译时默认将require的样式表插入head标签 1watchify -t cssify app.js &gt; bundle.js 包含预处理器编译的 node-lessify require-stylify 以require-stylify为例，node-lessify很类似，但是只能编译less 123npm install -S-dev browserifynpm install -S-dev watchify npm install -S-dev require-stylify app.js 12require('./less/main.less');require('./sass/sassFile.scss'); 编译后被引入的样式表就会出现在head标签中了， 1watchify -t require-stylify app.js &gt; bundle.js 实际上样式被编译后，生成的css文件直接存在于预处理文件的同目录下 即./less/main.css./sass/sassFile.css 总结以上，个人觉得虽然失去了异步模块的特性，但是作为现代模块工具，Browserify配合script标签的async属性，完全可以适用于生产环境，而且相应灵活性更高，社区的插件更丰富。 感谢阅读","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://mrpeak.github.io/tags/前端/"},{"name":"工具","slug":"工具","permalink":"https://mrpeak.github.io/tags/工具/"}]},{"title":"解决 Heroku 添加 Add-ons 的问题","slug":"heroku-addon","date":"2014-12-02T11:12:11.000Z","updated":"2016-06-13T08:18:31.000Z","comments":true,"path":"2014/12/02/heroku-addon/","link":"","permalink":"https://mrpeak.github.io/2014/12/02/heroku-addon/","excerpt":"介绍Heroku 作为为数不多的优秀 兼顾免费 的云平台，为开发者提供不揪心 的网站托管服务 为了对你的网站应用方便地添加各式各样的服务，Heroku 提供了 add-ons 的自助添加功能，即“附加组件”","text":"介绍Heroku 作为为数不多的优秀 兼顾免费 的云平台，为开发者提供不揪心 的网站托管服务 为了对你的网站应用方便地添加各式各样的服务，Heroku 提供了 add-ons 的自助添加功能，即“附加组件” 但是没有经过账户认证的话是无法使用免费 add-ons 的，所谓账户认证（Account Verify）就是对用户的信用卡进行认证绑定，所以，无论你是否使用付费的 add-ons ，信用卡验证这步是必须要走的。 补充下，heroku postgres 是唯一不需要认证使用的组件，PostgreSQL 是 Heroku 默认使用的数据库，这个组件就是提供基于它的数据库服务 当然，有的服务组件所在的网站单独对其服务进行提供，我使用过的如 MongoHQ, Mailgun。并且通过使用 Heroku SDK 的命令行工具也可以利用hack的方式接入组件的服务，参考：How to use MongoHQ on Heroku without Verifying your Account。不过为了能便捷全面地使用附加组件，还是推荐大家通过添加信用卡进行验证，不然下面的话我都不用写了。 验证身份首先你要有一张信用卡。普通的信用卡，如招商银行的Young卡是不可以的，常见的 Visa 和 MasterCard都支持认证的。小弟毕竟图样，对于信用卡研究的很浅，通过 你知道信用卡的五大品牌是什么吗？ 你可以总览下五大品牌 进入个人账户页面https://dashboard-next.heroku.com/account，老版界面点击 Add Credit Card，新版点击 Billing，之后出现了认证弹出窗 这些信息都是要填满的，可以用中文填，为了今后付账的便捷，尽量还是用英文混合汉语拼音进行输入，关于 Billing Address 如何填写，引用如下： Billing address，即信用卡账单地址，要求提供Billing Address往往是为了验证信用卡使用者是否为持有者本人，所以通常Billing Address信用卡账单地址应该和Shipping address寄送地址是一致的 而Shipping address是商品邮寄地址，就是寄送地址，了解下就行 我用的是招商银行的visa ~~~~ 其实只要卡号和过期时间填写正确了就可以了。。。 ！！！（如果使用别人的卡进行验证一定要通知当事人，因为信用卡是不需要密码验证的，只要知道信用卡持有者的姓名和卡表面上的基本信息就可以） 提交表单后就完成后会快就自动验证通过了。之后就可以开森地使用 Heroku 海量 add-ons 的 freeplan 装点你的网站应用啦 参考链接： http://xinyongka.baike.com/article-4442.html","categories":[],"tags":[{"name":"web服务","slug":"web服务","permalink":"https://mrpeak.github.io/tags/web服务/"}]},{"title":"查看jQuery元素真正的事件绑定","slug":"jquery-events","date":"2014-09-26T14:18:02.000Z","updated":"2016-06-13T08:32:40.000Z","comments":true,"path":"2014/09/26/jquery-events/","link":"","permalink":"https://mrpeak.github.io/2014/09/26/jquery-events/","excerpt":"希望查看页面上某一个元素的事件绑定逻辑的话，该怎么办？","text":"希望查看页面上某一个元素的事件绑定逻辑的话，该怎么办？ 举个🌰 在阿里巴巴国际站的SearchBar上 如果想查看红框内元素所绑定事件的逻辑，可能想到的方法可能有哪些呢? 通常想到的方法 控制台输出对应元素绑定的事件 1getEventListeners(elem) //将输出 Object &#123;mouseover: Array[1], mouseout: Array[1], mousedown: Array[1]&#125; 可以看到在这个元素上面绑定的事件和对应的事件处理函数，但是绑定逻辑并不是我们自己的代码，而是找到了 jQuery 封装的事件 通过开发者工具的 Elements 面板 —— Event Listener 然而通过查看 handler 看到的还是 jQuery 的那层壳，也并不是我们想要的 火狐的开发者版会自动标识出绑定了事件的元素（开发者版本自带的 devTools 甩开 firebug 几条街） 火狐也只是把jQuery的壳找到了 遇到的问题以上的方法在 JS Library 的封装下都不能顺利找到事件真正的处理逻辑, 下面依次介绍几种可行的解决方案 找到封装后的事件逻辑查看调用栈按图索骥人肉活, 不赘述 通过jQuery的私有方法 1$._data($('.ui-header-action-rfq')[0], 'events') // $._data() 第一个参数必须是DOM元素，不能传入 jQuery 对象和选择器字符串 在返回的对象中找到了时间绑定的处理函数，鼠标浮于handler，右键选择 Show Function Definition，即可跳转至脚本处理逻辑了。 $._data 不是公开方法，在1.8 版本之前存在 $.fn.data(‘events’) 方法直接查看对象绑定的函数，为啥被丢弃请看 http://bugs.jquery.com/ticket/10589 使用 Chome 扩展插件jQuery Audit 可以方便我们在页面暴露出jQuery全局变量时方便地调试jQ代码, 查看事件逻辑也不是难事! 如图：选中元素，右侧面板直接查看，爽歪歪","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://mrpeak.github.io/tags/JavaScript/"}]},{"title":"一系列JavaScript的基础工具","slug":"fe-tools","date":"2014-09-10T07:06:19.000Z","updated":"2016-06-13T08:05:10.000Z","comments":true,"path":"2014/09/10/fe-tools/","link":"","permalink":"https://mrpeak.github.io/2014/09/10/fe-tools/","excerpt":"一般的工具脚手架工具（帮助启动项目） Yeoman－Yeoman是一个强健且固执的客户端堆栈，其包含一些能帮助开发人员快速构建漂亮web应用程序的工具和框架。 构建工具（自动化的） Grunt.js—Grunt生态系统非常庞大,并且一直在增长。由于拥有数量庞大的插件可供选择，因此，你可以利用Grunt自动完成任何事,并且花费最少的代价。 Pint.js（Grunt的助手 ）－Pint是一个小型，异步的GruntJS运行器，试图解决大规模构建流程中的一些问题。","text":"一般的工具脚手架工具（帮助启动项目） Yeoman－Yeoman是一个强健且固执的客户端堆栈，其包含一些能帮助开发人员快速构建漂亮web应用程序的工具和框架。 构建工具（自动化的） Grunt.js—Grunt生态系统非常庞大,并且一直在增长。由于拥有数量庞大的插件可供选择，因此，你可以利用Grunt自动完成任何事,并且花费最少的代价。 Pint.js（Grunt的助手 ）－Pint是一个小型，异步的GruntJS运行器，试图解决大规模构建流程中的一些问题。 Gulp.js－Gulp使用流式构建项目，且主张代码优先于配置。因此使创建过程更简单，直观。 Browserify.js （浏览器的）—Browserify 是一个允许我们写node.js-风格的模块，编译后给浏览器使用。就像node.js一样，我们在不同的文件中编写模块，用module.exports 导出外部方法和属性，用exports导出变量。 Uglify.js －Uglify.js 是NodeJS的一个JavaScript解析/压缩/美化库。 包管理工具 Homebrew（Mac OS）－Homebrew能安装你需要而苹果没有的东西。 Apt（Ubuntu）－apt-get命令是一个很强大的命令行工具，与Ubuntu的APT机制一起工作，能安装新的软件包，更新现有的软件包，能更新包列表索引，且甚至能能更新整个Ubuntu系统。 NPM－npm是Node.js的官方包管理器。 Bower－Bower是web的包管理器。 前端工具MVC框架 Backbone.js－Backbone.js通过提供带有键值绑定的模型和定制的事件，带有枚举功能的丰富的集合API，带有声明式事件处理的视图，而且将它所有这些东西通过一个RESTful JSON接口连接到你现有的API上面，来向Web应用程序提供架构。 Ember.js－当底层模型变化时能保持你的HTML最新，那么Ember.js能让Handlebars模板更胜一筹。 Angular.js－AngularJS能让你为你的应用扩展HTML词汇。它能让程序更富表现力，更具可读性，更快的构建程序。 模板 Handlebars.js－Handlebars提供了必要的能力，让你能有效的构建语义模板。Mustache模板兼容Handlebars，因此你可以把Mustache模板导入到Handlebars中，来利用Handlebars额外的特性。 Mustache.js（比Handlebars少外置元素）－Mustache是一个支持ActionScript, C++, Clojure, CoffeeScript, ColdFusion, D, Erlang, Fantom, Go, Java, JavaScript, Lua, .NET, Objective-C, Pharo, Perl, PHP, Python, Ruby, Scala and XQuery.的简单的web模板系统。 Jade－Jade是一个主要为node.js服务器端模板设计的节点模板引擎。 Haml.js－Haml.js能让Haml语法在JavaScript工程中使用。其有许多与原生Haml相同的功能。 Eco－Eco能在你的标记中嵌入CoffeeScript 逻辑。 测试 Casper.js－CasperJS是一个导航脚本处理和测试JavaScript中 PhantomJS 和类似的SlimerJS书写的工具。 Zombie.js－Zombie.js是一个通过模拟环境来测试客户端JavaScript代码的轻量框架。不需要浏览器。 后端工具服务器 Express－Express是一个Node的web应用框架。 Node－Node.js是一个基于Chrome JavaScript 运行时建立的一个平台，用来方便地搭建快速的， 易于扩展的网络应用。 数据库 MongoDB－MongoDB是一款开源的文档型数据库，是NoSQL数据库中最热的一款。 Postgresql－Postgresql是一个强大的，开源，对象关系的数据库系统。 SQL－SQL被用来与数据库进行通信。美国国家标准协会规定，它是关系型数据库管理系统的标准语言。 架构风格 RESTful－REST是一个架构风格，由一套协调的体系结构约束组成，在分布式超媒体系统中应用组件，连接器和数据元素。 测试 Cucumber.js－Cucumber.js是一个能让你在JavaScript堆栈中使用目前流行的行为驱动模式的工具。 Jasmine－Jasmine是一个JavaScript的行为驱动开发测试框架。它不依赖于浏览器，DOM或任何JavaScript框架。因此它适合于web站点，Node.js工程或任何JavaScript能运行的地方。 Mocha－Mocha是一个在noce.js和浏览器上运行的富功能JavaScript测试框架，它让异步测试变得简单有趣。 Q-Unit－Q-Unit是一个功能强大，易于使用的JavaScript单元测试框架。它被应用于jQuery，jQuery UI和jQuery移动开发的工程中，它能测试任何通用的JavaScript代码。 Assertion（断言） 库 Chai－Chai是一个 node和浏览器的BDD/TDD Assertion（断言） 库，它能与任何JavaScript测试框架进行很好的配合。 函数化编程工具 Underscore.js - Underscore是一个在没有扩展任何内置对象情况下提供许多函数式编程帮助的JavaScript库。 Lo-Dash－Lo-Dash是一个提供一致性，定制性和表现性的实用库。 更新：还有其它你认为应该在这列举的工具吗？看看这篇文章和Github上有关MindNode的思维导图（OPML）。把你的建议发送给我们，让我们在此增加一些新鲜流行的工具！ 原文：codefellows.org","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://mrpeak.github.io/tags/前端/"},{"name":"工具","slug":"工具","permalink":"https://mrpeak.github.io/tags/工具/"}]},{"title":"用 Highchart 绘制 SVG","slug":"highchart-svg","date":"2014-09-06T02:54:22.000Z","updated":"2016-06-13T08:05:26.000Z","comments":true,"path":"2014/09/06/highchart-svg/","link":"","permalink":"https://mrpeak.github.io/2014/09/06/highchart-svg/","excerpt":"介绍做过数据可视化的同学对于HIGHCHARTS可能并不陌生，甚至是家族的其他两个成员 HIGHSTOCK 和 HIGHMAPS 也使用过 它对新老浏览器的兼容性和响应式特性是我们偏爱使用它的主要原因，当然文档齐全和demo丰富也是它的特点 下面是它的兼容性表格： Brand Versions supported Internet Explorer 6.0 + Firefox 2.0 + Chrome 1.0 + Safari 4.0 + Opera 9.0 + iOS (Safari) 3.0 + Android Browser 2.0 +","text":"介绍做过数据可视化的同学对于HIGHCHARTS可能并不陌生，甚至是家族的其他两个成员 HIGHSTOCK 和 HIGHMAPS 也使用过 它对新老浏览器的兼容性和响应式特性是我们偏爱使用它的主要原因，当然文档齐全和demo丰富也是它的特点 下面是它的兼容性表格： Brand Versions supported Internet Explorer 6.0 + Firefox 2.0 + Chrome 1.0 + Safari 4.0 + Opera 9.0 + iOS (Safari) 3.0 + Android Browser 2.0 + 基本覆盖了主要的桌面和移动浏览器，即使在天朝也可以放心使用，在IE9以下版本的浏览器会采用VML的降级方式渲染图形，在Android 2.X的原生浏览器会使用Canvas渲染图形 使用非商用证书可以免费使用 Highchart 的产品，如果商用的话，就要花费一笔购买许可证书之后再使用 使用API绘制图表、地图等等再这里就不细说了，绘制自定义图形是重点 当然，使用 d3, raphael, sylvester, ocanvas, two.js, svg.js, snap.svg 等图形库也可以帮助你绘制自定义图形，但是鉴于 HIGHCHART 的诸多优点，我习惯使用它 进入正题RenderderRenderer 这个构造器是绘制的核心，创建这个构造器的实例可以采用下面的方法 1var renderer = new Highcharts.Renderer(parentNode, width, height); 当调用 highcharts 方法时内部的 this.renderer 就是一个 Renderer 构造器的实例 1234567891011$('#container').highcharts(&#123; chart: &#123; backgroundColor: 'white', events: &#123; load: function () &#123; // Draw the flow chart var ren = this.renderer, &#125; &#125; &#125;&#125;); 在 highcharts-core 源码里我们可以看到，在Renderder的原型方法中，我们可以独立于 Chart 单独绘图的方法包括： path : 绘制路径 circle : 绘制圆形 arc : 绘制拱形 rect : 绘制矩形 g : 创建用于把相关元素进行组合的容器元素 image : 显示图片 text : 显示文字 label : 绘制一个具有阴影、边框、（渐变）背景色的 Label button: 绘制一个具有相应状态（hover, active .etc）的按钮，并可以绑定点击事件的回调函数 elementElement 构造器是 highchart 里 svg 元素 的 constructor，它也提供了一些实用的原型方法供实例调用： add : 像渲染画布中添加元素 animate : 对 svg/vml 元素使用动画效果，方法同 jQuery animate() 方法 attr : 为 svg/vml 元素添加属性，方法同 jQuery attr 方法 css : 不罗嗦。。同 jQuery destroy : 删除元素并释放内存 on : 为元素绑定事件处理函数 toFront : 前置元素 一言不合, 开始编码以NCZ大师那篇划时代的前后端分离文章的配图为目标，用 Renderer 实例来绘制相同的原理图 为了节省时间只画了上半部分 绘制原理：添加前端部分的分组 12//declare Front-End partvar frontEnd = render.g().add(); 用 rect() 方法添加前端部分的底层画布，其实就是先声明一个矩形，由于 SVG 没有 z-index 的概念，因此绘制的顺序决定了元素是否显示（即覆盖与否），使用 highcharts 元素内置的 toFront() 方法可以让元素前置显示，但是在编写时保证清晰的顺序是最好的 1234//make canvas for front-endvar FECanvas = render.rect(0, 0, 600, 360).attr(&#123; 'fill': '#FDEADA'&#125;).add(frontEnd); 生成左侧文字，添加到分组，注意 text() 方法的后两个参数为 x 和 y 坐标 1234render.text('Front-End', 45, 164).attr(&#123; 'font-size': '19px', 'font-weight': 'bold'&#125;).add(frontEnd); 为第一个 label 创建分组，来盛放 chrome 那张 logo 和里面那个有边框的 label ，使用 image() 方法引入图片，再用 rect 和 text 组合的方式生成 Layer UI 的 label 1234567891011121314151617181920212223242526272829303132333435363738394041424344// handle FEGrah groupvar FEGrah = render.g().add(frontEnd);// 为了做出阴影的效果，先生成的矩形被覆盖，但是它的尺寸更大些，因而会水平输出1px的偏移边框，竖直露出2px的偏移边框render.rect(240, 25, 341, 88, 2).attr(&#123; fill: '#fff', stroke: '#A09286', 'stroke-width': '6px', 'stroke-opacity': '0.3'&#125;).add(FEGrah);render.rect(240, 25, 340, 86, 2).attr(&#123; 'fill': '#4F81BD', 'stroke': '#fff', 'stroke-width': '4px'&#125;).add(FEGrah);//draw chorme logorender.image('http://upload.wikimedia.org/wikipedia/commons/8/87/Google_Chrome_icon_(2011).png', 250, 30, 75, 75).add(FEGrah);render.rect(353, 46, 212, 47, 2).attr(&#123; fill: '#A09286', stroke: '#A09286', 'stroke-width': '6px', 'stroke-opacity': '0.3'&#125;).add(FEGrah);render.rect(353, 46, 210, 46, 2).attr(&#123; 'fill': '#9BBB59', 'stroke': '#fff', 'stroke-width': '4px'&#125;).add(FEGrah);render.text('UI Layer', 425, 75).attr(&#123; 'font-size': '19px'&#125;).css(&#123; 'color': '#fff'&#125;).add(FEGrah);render.text('Browser', 360, 140).attr(&#123; 'font-size': '19px', 'font-weight': 'bold'&#125;).add(FEGrah); 下图 nodejs logo 所在的 label 采用了 label() 方法来生成，传入文字和坐标，在 attr() 和 css() 方法里指定一些样式让生成的label更美观 12345678910111213141516render.label('UI Layer', 353, 257).attr(&#123; fill: \"#F79646\", stroke: 'white', 'stroke-width': 4, padding: 12, // 指定圆角半径 r: 2, width: 185&#125;).css(&#123; textAlign: 'center', color: '#fff', fontSize: '19px'// 添加进 FEGrah2 分组 &#125;).add(FEGrah2)// shadow() 方法传入 true 时，label 自带 drop-shadow.shadow(true); 箭头部分是难点，箭头采用了 path() 方法绘制，定义坐标系原点，然后通过路径数组来自定义路径轨迹，箭头1便是这么画出来的，传入数组： 12345678910111213// 'm' 声明了坐标系原点位于（370, 142）处，小写字母代表绝对值，大写字母代表相对值// 'l' 声明了接下来要连线到后面数值坐标位置，表示相对距离，如向左移动 `25px`, 向下移动 `36px`// 向右移动13px，竖直不变// 水平不变，向下移动 `55px`// 这样绘制最后可绘制出一个宽体箭头var arrowPath = ['m', 370, 142, 'l', -25, 36, 13, 0, 0, 55, 24, 0, 0, -55, 13, 0, -25, -36];var narrow = render.path(arrowPath).attr(&#123; stroke: '#EC9694', 'stroke-width': '2', fill: 'pink'&#125;).add(FENarrow); 为了节省精力，右边颠倒的箭头我们采用偷懒的方式，复制左边的箭头，然后把复制的箭头放进一个分组中，然后对这个单独的分组添加属性 transform 123456789101112var narrow2 = render.path(arrowPath).attr(&#123; stroke: '#EC9694', 'stroke-width': '2', fill: 'pink'&#125;).add(FENarrow2);// FENarrow2是个单独的分组FENarrow2.attr(&#123; // rotate(deg, x, y)，分辨传入旋转角度、旋转中心横坐标和旋转中心竖坐标 'transform': 'rotate(-180 397 189)' // 这样便实现了对左侧箭头的复制，并进行倒置、平移&#125;); demo展示 SVG展示：1234567891011121314151617181920212223242526272829303132333435363738394041&lt;svg version=\"1.1\" style=\"font-family:&amp;quot;Lucida Grande&amp;quot;, &amp;quot;Lucida Sans Unicode&amp;quot;, Arial, Helvetica, sans-serif;font-size:12px;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"600\" height=\"660\"&gt; &lt;desc&gt;Created with Highcharts 4.0.3&lt;/desc&gt; &lt;defs&gt;&lt;/defs&gt; &lt;g&gt; &lt;rect x=\"0\" y=\"0\" width=\"600\" height=\"360\" fill=\"#FDEADA\"&gt;&lt;/rect&gt; &lt;text x=\"45\" y=\"164\" font-size=\"19px\" font-weight=\"bold\"&gt;Front-End&lt;/text&gt; &lt;g&gt; &lt;rect x=\"240\" y=\"25\" width=\"341\" height=\"88\" rx=\"2\" ry=\"2\" fill=\"#fff\" stroke=\"#A09286\" stroke-width=\"6px\" stroke-opacity=\"0.3\"&gt;&lt;/rect&gt; &lt;rect x=\"240\" y=\"25\" width=\"340\" height=\"86\" rx=\"2\" ry=\"2\" fill=\"#4F81BD\" stroke=\"#fff\" stroke-width=\"4px\"&gt;&lt;/rect&gt; &lt;image preserveAspectRatio=\"none\" x=\"250\" y=\"30\" width=\"75\" height=\"75\" xlink:href=\"http://upload.wikimedia.org/wikipedia/commons/8/87/Google_Chrome_icon_(2011).png\"&gt;&lt;/image&gt; &lt;rect x=\"353\" y=\"46\" width=\"212\" height=\"47\" rx=\"2\" ry=\"2\" fill=\"#A09286\" stroke=\"#A09286\" stroke-width=\"6px\" stroke-opacity=\"0.3\"&gt;&lt;/rect&gt; &lt;rect x=\"353\" y=\"46\" width=\"210\" height=\"46\" rx=\"2\" ry=\"2\" fill=\"#9BBB59\" stroke=\"#fff\" stroke-width=\"4px\"&gt;&lt;/rect&gt; &lt;text x=\"425\" y=\"75\" font-size=\"19px\" style=\"color:#fff;fill:#fff;\"&gt; &lt;tspan&gt;UI Layer&lt;/tspan&gt; &lt;/text&gt; &lt;text x=\"360\" y=\"140\" font-size=\"19px\" font-weight=\"bold\"&gt;Browser&lt;/text&gt; &lt;/g&gt; &lt;g&gt; &lt;rect x=\"240\" y=\"240\" width=\"341\" height=\"88\" rx=\"2\" ry=\"2\" fill=\"#fff\" stroke=\"#A09286\" stroke-width=\"6px\" stroke-opacity=\"0.3\"&gt;&lt;/rect&gt; &lt;rect x=\"240\" y=\"240\" width=\"340\" height=\"86\" rx=\"2\" ry=\"2\" fill=\"#4F81BD\" stroke=\"#fff\" stroke-width=\"4px\"&gt;&lt;/rect&gt; &lt;image preserveAspectRatio=\"none\" x=\"245\" y=\"255\" width=\"100\" height=\"55\" xlink:href=\"http://nodejs.org/images/logos/nodejs.png\"&gt;&lt;/image&gt; &lt;g style=\"text-align:center;\" transform=\"translate(353,257)\"&gt; &lt;rect x=\"0\" y=\"0\" width=\"209\" height=\"47\" strokeWidth=\"4\" fill=\"none\" stroke=\"black\" stroke-width=\"5\" rx=\"2\" ry=\"2\" isShadow=\"true\" stroke-opacity=\"0.049999999999999996\" transform=\"translate(1, 1)\"&gt;&lt;/rect&gt; &lt;rect x=\"0\" y=\"0\" width=\"209\" height=\"47\" strokeWidth=\"4\" fill=\"none\" stroke=\"black\" stroke-width=\"3\" rx=\"2\" ry=\"2\" isShadow=\"true\" stroke-opacity=\"0.09999999999999999\" transform=\"translate(1, 1)\"&gt;&lt;/rect&gt; &lt;rect x=\"0\" y=\"0\" width=\"209\" height=\"47\" strokeWidth=\"4\" fill=\"none\" stroke=\"black\" stroke-width=\"1\" rx=\"2\" ry=\"2\" isShadow=\"true\" stroke-opacity=\"0.15\" transform=\"translate(1, 1)\"&gt;&lt;/rect&gt; &lt;rect x=\"0\" y=\"0\" width=\"209\" height=\"47\" strokeWidth=\"4\" fill=\"#F79646\" stroke=\"white\" stroke-width=\"4\" rx=\"2\" ry=\"2\"&gt;&lt;/rect&gt; &lt;text x=\"67.5\" zIndex=\"1\" style=\"font-size:19px;color:#fff;fill:#fff;\" y=\"30\"&gt; &lt;tspan&gt;UI Layer&lt;/tspan&gt; &lt;/text&gt; &lt;/g&gt; &lt;text x=\"375\" y=\"354\" font-size=\"19\" font-weight=\"bold\"&gt;Server&lt;/text&gt; &lt;/g&gt; &lt;g&gt; &lt;path fill=\"pink\" d=\"m 370 142 l -25 36 13 0 0 55 24 0 0 -55 13 0 -25 -36\" stroke=\"#EC9694\" stroke-width=\"2\"&gt;&lt;/path&gt; &lt;/g&gt; &lt;g transform=\"rotate(-180 397 189)\"&gt; &lt;path fill=\"pink\" d=\"m 370 142 l -25 36 13 0 0 55 24 0 0 -55 13 0 -25 -36\" stroke=\"#EC9694\" stroke-width=\"2\"&gt;&lt;/path&gt; &lt;/g&gt; &lt;/g&gt; &lt;text x=\"455\" y=\"195\" font-size=\"19\" font-weight=\"bold\"&gt;HTTP/HTTPS&lt;/text&gt;&lt;/svg&gt; 参考链接： http://www.w3.org/TR/SVG/propidx.htmlhttp://api.highcharts.com/highcharts#Renderer Best wish!","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://mrpeak.github.io/tags/前端/"},{"name":"SVG","slug":"SVG","permalink":"https://mrpeak.github.io/tags/SVG/"},{"name":"图表","slug":"图表","permalink":"https://mrpeak.github.io/tags/图表/"}]},{"title":"PPT 在 Web 端的展示方法","slug":"web-ppt","date":"2014-05-29T04:16:11.000Z","updated":"2016-06-13T08:02:18.000Z","comments":true,"path":"2014/05/29/web-ppt/","link":"","permalink":"https://mrpeak.github.io/2014/05/29/web-ppt/","excerpt":"起最近做的项目有个需求是PPT的在线（Web端）展示，要求做到下面几点: 可以全屏播放 文档不能被下载 Flash Free （不依赖Flash插件） 不用代理可以访问资源（最基本的一点） 承想到的办法：","text":"起最近做的项目有个需求是PPT的在线（Web端）展示，要求做到下面几点: 可以全屏播放 文档不能被下载 Flash Free （不依赖Flash插件） 不用代理可以访问资源（最基本的一点） 承想到的办法： 转成pdf，浏览器原生支持播放pdf，&lt;iframe&gt;标签可以完成嵌套功能，如&lt;iframe src=&quot;./XX.pdf&quot; allowfullscreen=&quot;true&quot;&gt; 优点： 浏览器原生支持，网络消耗很小 文档视图可以放大缩小 简单（powerponit里直接导出为pdf） 缺点： 无法限制访问者下载文档 不能实现翻页浏览，只能滚动下拉 转成video（如mp4，swf），上传视频网站（Youtube支持H5播放）然后内嵌到自己的网站，或者自己用H5播放器播放本地视频。 给几个转格式的工具网站PowerPoint to DVD ConverterPowerPoint to Video ConverterPowerPoint to Web Video Converter 优点： HTML5 &lt;video&gt; 原生支持 缺点： 麻烦，转格式是个体力活 不能精确定位帧数 体验不好 利用 PowerPoint 2010 另存为 .html格式的文件然后用iframe内嵌到网站（没装Office，我没试过） 借助第三方的文档分享网站，上传文档，然后取得Embed代码，自己定义样式，嵌入自己的网站。 列举几个免费的站点： http://www.slideshare.net 优点： 网站很简约，播放界面灰常美观 展示image达到播放效果，纯HTML代码 自由控制访问权限，下载权限 缺点： 需要开代理才能访问资源（致命。。。） http://www.authorstream.com http://www.slideworld.com http://www.slideserve.com http://www.powershow.com/ http://www.myplick.com 上面5个网站我一起说，就不贴图了，类似于slideshare，不同点是这五个网站生成的embed代码依赖Flash，所以很不推荐。而且和slideshare一样需要开代理才能加载资源，一般用户无法访问。 文档管理类网站的发布功能 OneDrive 微软的在线文档服务 登陆OneDrive，新建文档 编辑文档——文件——共享——嵌入——Copy代码 微软自家的文档分享功能本应是最好的选择，可是不能限制访问者下载是个弊端。 GoogleDrive 谷歌的在线文档服务 Google Drive 的访问更苛刻，GAE开代理都上不去，必须用VPN，中国 ZOHO 优点： 这个站点很有意思，除了文档管理还有很多其他功能，免费班支持文档共享、发布。 网站风格很清爽，体验不错。 以 SVG 展示幻灯片，动画效果完整还原 支持批量上传和处理，简化劳动力 不用翻墙（O·M·G!!!） 缺点： IE8等等不支持SVG的浏览器要扑街（Who cares!） 接根据各项因素的考虑 如国内大多数用户能正常浏览，移动端可以播放，Flash Free，美观程度等等因素 ZOHO的文档服务是我的最后选择。 收附上ZOHO的展示","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://mrpeak.github.io/tags/前端/"},{"name":"演示文稿","slug":"演示文稿","permalink":"https://mrpeak.github.io/tags/演示文稿/"}]}]}